<!--
ColourTrading - Go-style prototype
Single-file HTML + CSS + JS.
How to use:
1. Save this file as ColourTrading_GoStyle.html
2. Open in a browser (double-click) to try locally.
3. To publish: push to GitHub and enable GitHub Pages, or drag to Netlify/Vercel.

Features in this prototype:
- Go-style grid (13x13) where players place colored "stones".
- Palette of colours for placement (each placement costs coins).
- Simple wallet with coins; free daily bonus button.
- Simple "marketplace" trade: convert all your stones of one colour to another at a rate.
- History log and basic undo.
- Responsive, single-file, ready to test and iterate.

This is a minimal prototype intended to demonstrate gameplay + trading concept. If you want
more advanced mechanics (captures, multiplayer, server persistence, user accounts, payments),
I can help extend it.
--> <!doctype html>

<html lang="hi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Colour Trading - Go-style Prototype</title>
  <style>
    :root{
      --bg:#f7f7f9; --board:#e6cfa8; --line:#6b4f2a; --panel:#ffffff;
      --accent:#2563eb; --muted:#6b7280;
    }
    *{box-sizing:border-box;font-family:Inter, system-ui, sans-serif}
    body{margin:0;background:var(--bg);color:#111}
    .wrap{max-width:1100px;margin:20px auto;padding:16px;display:grid;grid-template-columns:560px 1fr;gap:16px}
    header{grid-column:1/3;display:flex;justify-content:space-between;align-items:center}
    h1{margin:0;font-size:20px}
    .board-card{background:var(--panel);border-radius:12px;padding:14px;box-shadow:0 6px 18px rgba(16,24,40,0.06)}
    .board{background:var(--board);padding:14px;border-radius:8px;display:flex;justify-content:center}
    canvas{background:transparent;border-radius:6px}
    .controls{display:flex;flex-direction:column;gap:12px}
    .palette{display:flex;gap:8px;flex-wrap:wrap}
    .swatch{width:36px;height:36px;border-radius:6px;display:flex;align-items:center;justify-content:center;cursor:pointer;border:2px solid rgba(0,0,0,0.06)}
    .swatch.selected{outline:3px solid rgba(37,99,235,0.18)}
    .info{display:flex;gap:10px;align-items:center}
    .btn{background:var(--accent);color:white;padding:8px 12px;border-radius:8px;border:0;cursor:pointer}
    .btn.ghost{background:transparent;color:var(--accent);border:1px solid rgba(37,99,235,0.12)}
    .panel{background:var(--panel);padding:12px;border-radius:10px;box-shadow:0 6px 18px rgba(16,24,40,0.04)}
    .small{font-size:13px;color:var(--muted)}
    .market{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    textarea{width:100%;height:90px;border-radius:8px;padding:8px;border:1px solid #e5e7eb}
    footer{grid-column:1/3;text-align:center;color:var(--muted);font-size:13px;margin-top:8px}
    @media(max-width:900px){.wrap{grid-template-columns:1fr;}.board-card{order:2}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>ColourTrading — Go-style Prototype</h1>
      <div class="info">
        <div class="small">Wallet: <strong id="coins">100</strong> coins</div>
        <button class="btn ghost" id="daily">Daily +50</button>
      </div>
    </header><section class="board-card">
  <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
    <div><strong>Board</strong><div class="small">Click a cell to place a stone (cost: 5 coins)</div></div>
    <div class="small">Grid: <select id="gridSize"><option>9</option><option selected>13</option><option>19</option></select></div>
  </div>
  <div class="board"><canvas id="boardCanvas" width="520" height="520"></canvas></div>
  <div style="display:flex;gap:8px;margin-top:10px;justify-content:space-between;align-items:center">
    <div class="palette" id="palette"></div>
    <div style="display:flex;gap:8px;align-items:center">
      <button class="btn" id="undo">Undo</button>
      <button class="btn ghost" id="reset">Reset</button>
    </div>
  </div>
</section>

<aside class="controls">
  <div class="panel">
    <strong>Marketplace</strong>
    <div class="small">Exchange your stones from one colour to another</div>
    <div style="margin-top:8px" class="market">
      <div>
        <label class="small">From</label>
        <select id="fromColor"></select>
      </div>
      <div>
        <label class="small">To</label>
        <select id="toColor"></select>
      </div>
    </div>
    <div style="margin-top:8px;display:flex;gap:8px">
      <input type="number" id="rate" value="1" min="0" step="0.1" style="width:100%" />
      <button class="btn" id="trade">Trade</button>
    </div>
    <div class="small" style="margin-top:8px">Note: trade converts <em>all</em> your stones of chosen colour at the rate (new stones count = floor(old * rate)).</div>
  </div>

  <div class="panel">
    <strong>Board Stats</strong>
    <div class="small" id="stats">Empty board</div>
  </div>

  <div class="panel">
    <strong>History</strong>
    <div class="small" id="history">No moves yet.</div>
  </div>

  <div class="panel">
    <strong>Instructions</strong>
    <div class="small">This is a single-player prototype. You place coloured stones on a Go-style grid. Each placement costs coins. Use the marketplace to convert stones of one colour to another. When ready, upgrade to paid hosting or ask for multiplayer/server features.</div>
  </div>
</aside>

<footer>Prototype — ready to test. Want me to publish this on free hosting (GitHub Pages / Netlify)? I can guide you step-by-step.</footer>

  </div>  <script>
    // Configuration
    const COLORS = [
      {id:'red',hex:'#ef4444'},
      {id:'blue',hex:'#2563eb'},
      {id:'green',hex:'#10b981'},
      {id:'yellow',hex:'#f59e0b'},
      {id:'purple',hex:'#7c3aed'},
      {id:'black',hex:'#111827'}
    ];
    const PLACE_COST = 5;

    // State
    let gridN = 13;
    let board = [];
    let selectedColor = COLORS[0].id;
    let coins = 100;
    let history = [];

    // DOM
    const canvas = document.getElementById('boardCanvas');
    const ctx = canvas.getContext('2d');
    const paletteEl = document.getElementById('palette');
    const coinsEl = document.getElementById('coins');
    const statsEl = document.getElementById('stats');
    const historyEl = document.getElementById('history');
    const fromSel = document.getElementById('fromColor');
    const toSel = document.getElementById('toColor');
    const rateInput = document.getElementById('rate');

    function init(){
      initPalette();
      initSelectors();
      initBoard(gridN);
      draw();
      attachEvents();
      updateUI();
    }

    function initPalette(){
      paletteEl.innerHTML='';
      COLORS.forEach(c=>{
        const d = document.createElement('div');
        d.className='swatch'+(c.id===selectedColor?' selected':'');
        d.title = c.id;
        d.style.background = c.hex;
        d.onclick = ()=>{selectedColor=c.id; document.querySelectorAll('.swatch').forEach(s=>s.classList.remove('selected')); d.classList.add('selected');}
        paletteEl.appendChild(d);
      })
    }

    function initSelectors(){
      fromSel.innerHTML=''; toSel.innerHTML='';
      COLORS.forEach(c=>{
        const o1 = document.createElement('option'); o1.value=c.id; o1.textContent=c.id; fromSel.appendChild(o1);
        const o2 = document.createElement('option'); o2.value=c.id; o2.textContent=c.id; toSel.appendChild(o2);
      })
      toSel.value = 'black';
    }

    function initBoard(n){
      gridN = n; board = new Array(n).fill(0).map(()=>new Array(n).fill(null));
      history = [];
    }

    function attachEvents(){
      canvas.onclick = onCanvasClick;
      document.getElementById('undo').onclick = undo;
      document.getElementById('reset').onclick = ()=>{if(confirm('Reset board?')){initBoard(gridN);draw();updateUI();}};
      document.getElementById('trade').onclick = doTrade;
      document.getElementById('daily').onclick = ()=>{coins+=50; updateUI();};
      document.getElementById('gridSize').onchange = (e)=>{initBoard(Number(e.target.value)); resizeCanvas(); draw(); updateUI();}
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();
    }

    function resizeCanvas(){
      const size = Math.min(520, Math.floor((window.innerWidth-120)/1.1));
      canvas.width = canvas.height = Math.min(520, size);
      draw();
    }

    function draw(){
      const w = canvas.width; const h = canvas.height; ctx.clearRect(0,0,w,h);
      // board background
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--board') || '#e6cfa8';
      ctx.fillRect(0,0,w,h);
      // grid lines
      ctx.strokeStyle = 'rgba(107,79,42,0.85)'; ctx.lineWidth=1.5;
      const pad = 28; const gw = (w-2*pad)/(gridN-1);
      for(let i=0;i<gridN;i++){
        ctx.beginPath(); ctx.moveTo(pad + i*gw, pad); ctx.lineTo(pad + i*gw, h-pad); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(pad, pad + i*gw); ctx.lineTo(w-pad, pad + i*gw); ctx.stroke();
      }
      // stones
      for(let r=0;r<gridN;r++)for(let c=0;c<gridN;c++){
        const val = board[r][c]; if(!val) continue;
        const x = pad + c*gw; const y = pad + r*gw;
        drawStone(x,y,gw*0.9/2,val);
      }
    }

    function drawStone(x,y,r,colorId){
      const color = COLORS.find(c=>c.id===colorId)?.hex || '#000';
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle=color; ctx.fill();
      ctx.lineWidth=2; ctx.strokeStyle='rgba(255,255,255,0.25)'; ctx.stroke();
    }

    function onCanvasClick(e){
      const rect = canvas.getBoundingClientRect(); const x = e.clientX-rect.left; const y = e.clientY-rect.top;
      const w = canvas.width; const pad = 28; const gw = (w-2*pad)/(gridN-1);
      const cx = Math.round((x-pad)/gw); const cy = Math.round((y-pad)/gw);
      if(cx<0||cy<0||cx>=gridN||cy>=gridN) return;
      // place if empty and enough coins
      if(board[cy][cx]){alert('Cell already occupied'); return;}
      if(coins < PLACE_COST){alert('Not enough coins'); return;}
      board[cy][cx] = selectedColor;
      coins -= PLACE_COST; history.push({type:'place',x:cx,y:cy,color:selectedColor});
      draw(); updateUI();
    }

    function countStones(){
      const counts = {};
      COLORS.forEach(c=>counts[c.id]=0);
      for(let r=0;r<gridN;r++)for(let c=0;c<gridN;c++){ const v=board[r][c]; if(v) counts[v]++; }
      return counts;
    }

    function updateUI(){
      coinsEl.textContent = coins;
      const counts = countStones();
      const parts = COLORS.map(c=>`${c.id}: ${counts[c.id]}`);
      statsEl.innerHTML = parts.join(' • ');
      historyEl.textContent = history.length? history.slice(-10).map(h=>{
        if(h.type==='place') return `Placed ${h.color} @ (${h.x+1},${h.y+1})`;
        return JSON.stringify(h);
      }).join('\n') : 'No moves yet.';
    }

    function undo(){
      const last = history.pop(); if(!last) return alert('Nothing to undo');
      if(last.type==='place'){ board[last.y][last.x]=null; coins += PLACE_COST; draw(); updateUI(); }
    }

    function doTrade(){
      const from = fromSel.value; const to = toSel.value; const rate = parseFloat(rateInput.value) || 1;
      if(from===to) return alert('Choose two different colours');
      // count user's stones of 'from'
      const counts = countStones(); const have = counts[from] || 0;
      if(!have) return alert('You have no stones of that colour to trade');
      const newCount = Math.floor(have * rate);
      // perform conversion: remove all 'from' stones and add 'newCount' stones of 'to' into empty cells (nearest empty)
      // remove
      for(let r=0;r<gridN;r++)for(let c=0;c<gridN;c++) if(board[r][c]===from) board[r][c]=null;
      // place new stones
      let placed=0;
      outer: for(let r=0;r<gridN;r++){
        for(let c=0;c<gridN;c++){
          if(placed>=newCount) break outer;
          if(!board[r][c]){ board[r][c]=to; placed++; }
        }
      }
      history.push({type:'trade',from,to,had:have,got:placed,rate});
      // small fee
      const fee = Math.max(0, Math.floor(have*0.2)); coins = Math.max(0, coins - fee);
      draw(); updateUI();
      alert(`Traded ${have} ${from} -> ${placed} ${to} (rate ${rate}). Fee: ${fee} coins`);
    }

    // init
    init();
  </script></body>
</html>
